var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SSNVariability","category":"page"},{"location":"#SSNVariability","page":"Home","title":"SSNVariability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nothing to see here!","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SSNVariability]","category":"page"},{"location":"#SSNVariability.diagtozero!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"SSNVariability.diagtozero!","text":"diagtozero!(M::AbstractMatrix{T}) where T\n\nReplaces the matrix diagonal with zeros\n\n\n\n\n\n","category":"method"},{"location":"#SSNVariability.jacobian-Union{Tuple{R}, Tuple{Vector{R}, SSNVariability.RecurrentNeuralNetwork{R}}} where R","page":"Home","title":"SSNVariability.jacobian","text":"    jacobian(u,rn::RecurrentNetwork)\n\nJacobian matrix of the network dynamics at point u\n\n\n\n\n\n","category":"method"},{"location":"#SSNVariability.norm_sum_rows!-Tuple{Any}","page":"Home","title":"SSNVariability.norm_sum_rows!","text":"norm_sum_rows!(mat)\n\nRescales the matrix by row so that the sum of each row is 1.0\n\n\n\n\n\n","category":"method"},{"location":"#SSNVariability.random_covariance_matrix","page":"Home","title":"SSNVariability.random_covariance_matrix","text":"random_covariance_matrix(dims::Integer,diag_val::Real,k_dims::Integer=5)\n\nReturns a random covariance matrix that is positive definite and has off-diagonal elements.\n\nArguments\n\nd: dimensions\ndiag_val: scaling of the diagonal\nk-dims: to regulate off-diagonal elements\n\n\n\n\n\n","category":"function"},{"location":"#SSNVariability.run_network_nonoise-Union{Tuple{R}, Tuple{SSNVariability.RecurrentNeuralNetwork{R}, Vector{R}, Real}} where R<:Real","page":"Home","title":"SSNVariability.run_network_nonoise","text":"function runnetworknonoise(ntw::RecurrentNeuralNetwork{R},rstart::Vector{R},       tend::Real; verbose::Bool=false,stepsize=0.05) where R<:Real\n\nRuns the network simulation without any external noise.\n\nArguments\n\nntw::RecurrentNeuralNetwork\nr_start::Vector : initial conditions\nt_end::Real: the maximum time considered\n\nOptional arguments\n\nverbose::Bool = false : ODE solver is verbose\nstepsize::Real = 0.05 : stepsize for saving the solution (not solver stepsize)\n\nOutputs\n\ntimes::Vector{R} : the times at which the solution is saved\nu_end::Matrix{R} : the final state\nr_end::Matrix{R} : the final state as rate\n\n\n\n\n\n","category":"method"},{"location":"#SSNVariability.run_network_to_convergence-Union{Tuple{R}, Tuple{SSNVariability.RecurrentNeuralNetwork{R}, Vector{R}}} where R","page":"Home","title":"SSNVariability.run_network_to_convergence","text":"runnetworktoconvergence(u0, rn::RecurrentNeuralNetwork ;                 tend=80. , veltol=1E-4) Runs the network as described in run_network_nonoise, but stops as soon as norm(v) / n < veltol where v is the velocity at time t. If this condition is not satisfied (no convergence to attractor), it runs until t_end and prints a warning.\n\nArguments\n\nrn::RecurrentNeuralNetwork\nr_start::Vector : initial conditions\nt_end::Real: the maximum time considered\nveltol::Real : the norm (divided by num. dimensions) for velocity at convergence\n\nOutputs\n\nu_end::Vector : the final state at convergence\nr_end::Vector : the final state at convergence as rate\n\n\n\n\n\n","category":"method"}]
}
